// Generated by CoffeeScript 1.6.3
(function() {
  var Client, GameClient, WebClient, settings,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  settings = require("./settings");

  
splitParams = function(str, count){
	var result = [];
	var remain = str;
	for(var _i=0;_i<count-1;++_i){
		var pos = remain.indexOf(",");
		if(pos >= 0){
			result.push(remain.substring(0, pos));
			remain = remain.substring(pos+1);
		}
	}
	result.push(remain);
	return result;
}

Array.prototype.remove = function(obj) {
	for(var i in this) {
		if(this[i] === obj){
			this.splice(i, 1);
			return;
		}
	}
};

Date.prototype.format = function (fmt) { //author: meizz 
    var o = {
        "M+": this.getMonth() + 1, //月份 
        "d+": this.getDate(), //日 
        "h+": this.getHours(), //小时 
        "m+": this.getMinutes(), //分 
        "s+": this.getSeconds(), //秒 
        "q+": Math.floor((this.getMonth() + 3) / 3), //季度 
        "S": this.getMilliseconds() //毫秒 
    };
    if (/(y+)/.test(fmt)) fmt = fmt.replace(RegExp.$1, (this.getFullYear() + "").substr(4 - RegExp.$1.length));
    for (var k in o)
    if (new RegExp("(" + k + ")").test(fmt)) fmt = fmt.replace(RegExp.$1, (RegExp.$1.length == 1) ? (o[k]) : (("00" + o[k]).substr(("" + o[k]).length)));
    return fmt;
}

;

  Client = (function() {
    function Client(socket, isWeb) {
      this.socket = socket;
      this.isWeb = isWeb;
      this.id = this.socket.id;
    }

    return Client;

  })();

  GameClient = (function(_super) {
    __extends(GameClient, _super);

    function GameClient(socket, authorization) {
      this.authorization = authorization;
      GameClient.__super__.constructor.call(this, socket, false);
      this.title = new Date().format("yyyy-MM-dd hh:mm:ss");
      this.logs = [];
      this.webClients = [];
    }

    GameClient.prototype.getLog = function(logId) {
      while (!(this.logs.length > logId)) {
        this.logs.push(null);
      }
      if (this.logs[logId] === null) {
        this.logs[logId] = {
          id: logId,
          type: '_',
          message: null,
          trace: null
        };
      }
      return this.logs[logId];
    };

    GameClient.prototype.addLog = function(logId, logType, logMessage) {
      var log, webClient, _i, _len, _ref, _results;
      log = this.getLog(logId);
      log.type = logType;
      log.message = logMessage;
      _ref = this.webClients;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        webClient = _ref[_i];
        _results.push(webClient.emitLog(log));
      }
      return _results;
    };

    GameClient.prototype.addTrace = function(logId, logTrace) {
      var log;
      log = this.getLog(logId);
      return log.trace = logTrace;
    };

    GameClient.prototype.toEssential = function() {
      return {
        id: this.id,
        authorization: this.authorization,
        title: this.title
      };
    };

    return GameClient;

  })(Client);

  WebClient = (function(_super) {
    __extends(WebClient, _super);

    function WebClient(socket) {
      WebClient.__super__.constructor.call(this, socket, true);
      this.currentSession = null;
    }

    WebClient.prototype.emitLog = function(log) {
      var l;
      l = log;
      return this.socket.emit("log", {
        id: l.id,
        type: l.type,
        message: l.message
      });
    };

    WebClient.prototype.startInspect = function(session) {
      var l;
      this.currentSession = session;
      this.currentSession.webClients.push(this);
      return this.socket.emit("ready", (function() {
        var _i, _len, _ref, _results;
        _ref = this.currentSession.logs;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          l = _ref[_i];
          if (l !== null) {
            _results.push({
              id: l.id,
              type: l.type,
              message: l.message
            });
          }
        }
        return _results;
      }).call(this));
    };

    WebClient.prototype.stopInspect = function() {
      if (this.currentSession === null) {
        return;
      }
      this.currentSession.webClients.remove(this);
      return this.currentSession = null;
    };

    WebClient.prototype.notifySessionBorn = function(session) {
      return this.socket.emit("born", session.toEssential());
    };

    WebClient.prototype.notifySessionDied = function(session) {
      return this.socket.emit("died", session.id);
    };

    return WebClient;

  })(Client);

  exports.listen = function(server) {
    var activeAuthorizations, activeSessions, activeWebs, addActiveSession, addActiveWeb, allSessions, clients, io, name, removeActiveSession, removeActiveWeb, _i, _len, _ref;
    activeAuthorizations = {};
    _ref = settings.authorizations;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      name = _ref[_i];
      activeAuthorizations[name] = null;
    }
    clients = {};
    allSessions = [];
    activeWebs = [];
    activeSessions = [];
    addActiveSession = function(socketId) {
      var session, webClientId, _j, _len1, _results;
      allSessions.push(socketId);
      activeSessions.push(socketId);
      session = clients[socketId];
      _results = [];
      for (_j = 0, _len1 = activeWebs.length; _j < _len1; _j++) {
        webClientId = activeWebs[_j];
        _results.push(clients[webClientId].notifySessionBorn(session));
      }
      return _results;
    };
    removeActiveSession = function(socketId) {
      var session, webClientId, _j, _len1, _results;
      activeSessions.remove(socketId);
      session = clients[socketId];
      _results = [];
      for (_j = 0, _len1 = activeWebs.length; _j < _len1; _j++) {
        webClientId = activeWebs[_j];
        _results.push(clients[webClientId].notifySessionDied(session));
      }
      return _results;
    };
    addActiveWeb = function(socketId) {
      return activeWebs.push(socketId);
    };
    removeActiveWeb = function(socketId) {
      var webClient;
      activeWebs.remove(socketId);
      webClient = clients[socketId];
      webClient.stopInspect();
      return delete clients[webClient];
    };
    io = require("socket.io").listen(server);
    io.set('log level', 2);
    return io.sockets.on("connection", function(socket) {
      console.log("Connection " + socket.id + " accepted.");
      socket.on("message", function(message) {
        var authorization, client, clientData, socketId, tempId, verb;
        socketId = socket.id;
        verb = splitParams(message, 2);
        switch (verb[0]) {
          case "CONNECT":
            authorization = verb[1];
            if (__indexOf.call(settings.authorizations, authorization) >= 0 && activeAuthorizations[authorization] === null) {
              activeAuthorizations[authorization] = socketId;
              client = clients[socketId] = new GameClient(socket, authorization);
              addActiveSession(socketId);
              return socket.send("AS");
            } else {
              return socket.send("RN");
            }
            break;
          case "LOG":
            client = clients[socketId];
            return client.addLog.apply(client, splitParams(verb[1], 3));
          case "TRACE":
            client = clients[socketId];
            return client.addTrace.apply(client, splitParams(verb[1], 2));
          case "WEB":
            client = clients[socketId] = new WebClient(socket);
            addActiveWeb(socketId);
            clientData = {};
            clientData.authorizations = settings.authorizations;
            clientData.sessions = (function() {
              var _j, _len1, _results;
              _results = [];
              for (_j = 0, _len1 = allSessions.length; _j < _len1; _j++) {
                tempId = allSessions[_j];
                _results.push(clients[tempId].toEssential());
              }
              return _results;
            })();
            clientData.activeSessions = activeSessions;
            return socket.emit("init", clientData);
          case "INSPECT":
            client = clients[socketId];
            return client.startInspect(clients[verb[1]]);
          default:
            return console.log("Unknown message verb: [" + verb[0] + "] from - " + message);
        }
      });
      return socket.on("disconnect", function() {
        var client;
        console.log("Connection " + socket.id + " terminated.");
        client = clients[socket.id];
        if (client instanceof GameClient) {
          activeAuthorizations[client.authorization] = null;
          removeActiveSession(socket.id);
          return console.log("GameClient closed");
        } else if (client instanceof WebClient) {
          removeActiveWeb(socket.id);
          return console.log("WebClient closed");
        }
      });
    });
  };

}).call(this);
